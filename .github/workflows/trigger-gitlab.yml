name: Trigger GitLab CI for Forge

# ============================================================================
# GitHub Workflow to Trigger GitLab CI
# ============================================================================
# This workflow triggers GitLab CI/CD pipeline when issues are opened with
# forge templates. The actual catalog generation runs on GitLab runners.
#
# Detection: Uses issue title prefixes ([Forge-Intake], [Forge-STAC], [Forge-All])
# to determine catalog type, since labels may not be applied immediately.
#
# Prerequisites:
# - GITLAB_TRIGGER_TOKEN: GitLab pipeline trigger token (set in GitHub secrets)
# - GITLAB_PROJECT_ID: GitLab project ID (set in GitHub secrets)
# ============================================================================

on:
  issues:
    types: [opened]

permissions:
  issues: write
  contents: read

jobs:
  check-and-trigger:
    name: Check Issue and Trigger GitLab
    runs-on: ubuntu-latest
    
    steps:
      - name: Check for forge issue
        id: check-forge
        run: |
          ISSUE_TITLE='${{ github.event.issue.title }}'
          echo "Issue title: $ISSUE_TITLE"
          
          # Check if the issue title contains a forge prefix
          if [[ "$ISSUE_TITLE" =~ \[Forge-(Intake|STAC|All)\] ]]; then
            echo "is_forge_issue=true" >> $GITHUB_OUTPUT
            echo "‚úì Forge issue detected from title"
          else
            echo "is_forge_issue=false" >> $GITHUB_OUTPUT
            echo "‚úó Not a forge issue"
          fi
      
      - name: Determine catalog type
        id: catalog-type
        if: steps.check-forge.outputs.is_forge_issue == 'true'
        run: |
          ISSUE_TITLE='${{ github.event.issue.title }}'
          echo "Analyzing title: $ISSUE_TITLE"
          
          # Determine catalog type from issue title prefix
          if [[ "$ISSUE_TITLE" =~ \[Forge-All\] ]]; then
            echo "type=all" >> $GITHUB_OUTPUT
            echo "job=forge:all" >> $GITHUB_OUTPUT
            echo "‚úì Catalog type: all (both intake and stac)"
          elif [[ "$ISSUE_TITLE" =~ \[Forge-STAC\] ]]; then
            echo "type=stac" >> $GITHUB_OUTPUT
            echo "job=forge:stac" >> $GITHUB_OUTPUT
            echo "‚úì Catalog type: stac"
          elif [[ "$ISSUE_TITLE" =~ \[Forge-Intake\] ]]; then
            echo "type=intake" >> $GITHUB_OUTPUT
            echo "job=forge:intake" >> $GITHUB_OUTPUT
            echo "‚úì Catalog type: intake"
          else
            echo "type=unknown" >> $GITHUB_OUTPUT
            echo "job=unknown" >> $GITHUB_OUTPUT
            echo "‚úó Could not determine catalog type from title"
          fi

      - name: Label issue
        if: steps.check-forge.outputs.is_forge_issue == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const catalogType = '${{ steps.catalog-type.outputs.type }}';
            const labels = [];
            
            if (catalogType === 'all') {
              labels.push('forge-all', 'forge-intake', 'forge-stac');
            } else if (catalogType === 'intake') {
              labels.push('forge-intake');
            } else if (catalogType === 'stac') {
              labels.push('forge-stac');
            }
            
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: labels
              });
              console.log(`‚úì Added labels: ${labels.join(', ')}`);
            }

      - name: Comment workflow started
        if: steps.check-forge.outputs.is_forge_issue == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const catalogType = '${{ steps.catalog-type.outputs.type }}';
            const comment = `üöÄ **Catalog generation started!**\n\n` +
              `The forge pipeline is now being triggered on GitLab CI.\n\n` +
              `**Catalog Type:** ${catalogType}\n` +
              `**Status:** Triggering GitLab pipeline...\n\n` +
              `You will be notified here when the generation is complete.`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Trigger GitLab CI Pipeline
        if: steps.check-forge.outputs.is_forge_issue == 'true'
        env:
          GITLAB_TRIGGER_TOKEN: ${{ secrets.GITLAB_TRIGGER_TOKEN }}
          GITLAB_PROJECT_ID: ${{ secrets.GITLAB_PROJECT_ID }}
          GITLAB_HOST: ${{ secrets.GITLAB_HOST || 'gitlab.com' }}
        run: |
          # Prepare issue body (escape for JSON)
          ISSUE_BODY=$(cat <<'EOF'
          ${{ github.event.issue.body }}
          EOF
          )
          
          # Trigger GitLab pipeline with issue context
          RESPONSE=$(curl -X POST \
            "https://${GITLAB_HOST}/api/v4/projects/${GITLAB_PROJECT_ID}/trigger/pipeline" \
            -F "token=${GITLAB_TRIGGER_TOKEN}" \
            -F "ref=main" \
            -F "variables[GITHUB_ISSUE_NUMBER]=${{ github.event.issue.number }}" \
            -F "variables[GITHUB_ISSUE_TITLE]=${{ github.event.issue.title }}" \
            -F "variables[GITHUB_ISSUE_BODY]=${ISSUE_BODY}" \
            -F "variables[GITHUB_ISSUE_LABELS]=${{ join(github.event.issue.labels.*.name, ',') }}" \
            -F "variables[CATALOG_TYPE]=${{ steps.catalog-type.outputs.type }}" \
            -F "variables[FORGE_JOB]=${{ steps.catalog-type.outputs.job }}" \
            -F "variables[GITHUB_TOKEN]=${{ secrets.GITHUB_TOKEN }}" \
            -F "variables[GITHUB_REPOSITORY]=${{ github.repository }}")
            -F "variables[GITHUB_TOKEN]=${{ secrets.GITHUB_TOKEN }}" \
            -F "variables[GITHUB_REPOSITORY]=${{ github.repository }}")
          
          echo "GitLab API Response:"
          echo "$RESPONSE" | jq '.'
          
          PIPELINE_ID=$(echo "$RESPONSE" | jq -r '.id')
          PIPELINE_URL=$(echo "$RESPONSE" | jq -r '.web_url')
          
          if [ "$PIPELINE_ID" != "null" ] && [ -n "$PIPELINE_ID" ]; then
            echo "‚úì Pipeline triggered successfully: $PIPELINE_URL"
            echo "pipeline_id=$PIPELINE_ID" >> $GITHUB_OUTPUT
            echo "pipeline_url=$PIPELINE_URL" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to trigger pipeline"
            exit 1
          fi
        id: trigger

      - name: Comment pipeline link
        uses: actions/github-script@v7
        if: success() && steps.check-forge.outputs.is_forge_issue == 'true'
        with:
          script: |
            const pipelineUrl = '${{ steps.trigger.outputs.pipeline_url }}';
            const comment = `‚úì GitLab pipeline triggered successfully!\n\n` +
              `**Pipeline:** [View on GitLab](${pipelineUrl})\n\n` +
              `The catalog will be generated on GitLab CI runners.\n\n` +
              `Once complete, a merge request will be created in GitLab for review. ` +
              `You will be notified here with the merge request link.`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Comment on failure
        uses: actions/github-script@v7
        if: failure() && steps.check-forge.outputs.is_forge_issue == 'true'
        with:
          script: |
            const comment = `‚ùå **Failed to trigger GitLab pipeline**\n\n` +
              `There was an error triggering the GitLab CI/CD pipeline.\n` +
              `Please check the workflow logs or contact the maintainers.\n\n` +
              `[View workflow run](${context.payload.repository.html_url}/actions/runs/${context.runId})`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
